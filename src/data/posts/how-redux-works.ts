import type { Post } from '../types/posts.types';

const post: Post = {
  id: 2,
  slug: 'how-redux-works',
  title: 'How Redux Works - Part 1',
  date: 'January 29, 2019',
  excerpt:
    "In this article we'll be covering createStore. This is the function that sets up the redux store and provides access to getState, dispatch, subscribe, and replaceReducer. ",
  content: `
<p><em>This is part one of a two part series. For part two <a href="/writing/how-redux-works-2">see here</a>.</em></p>
<h1 id="create-store">Create Store</h1>
<p>I spend a lot of time walking people through Redux best practices and how to use it, and throughout this process I've found it really helpful to dive into the source itself. While this source is very readable and well commented, I thought I'd put together a blog post to break it down and add some more context.</p>
<p>In this article we'll be covering <code><a href="https://github.com/reduxjs/redux/blob/master/src/createStore.js">createStore</a></code>. This is the function that sets up the redux store and provides access to <code>getState</code>, <code>dispatch</code>, <code>subscribe</code>, and <code>replaceReducer</code>. </p>
<p><em>A note on embedded source: The most up to date redux source is <a href="https://github.com/reduxjs/redux/tree/master/src">available here</a>. I'll be embedding source code as of when this post was written.</em></p>
<h1 id="three-principals">Three Principals</h1>
<p>Before we get started we should reexamine the <a href="https://redux.js.org/introduction/three-principles">three principals</a> of redux. Below is an excerpt from the redux docs.</p>
<h3 id="single-source-of-truth">Single source of truth</h3>
<p>The <a href="https://redux.js.org/glossary#state">state</a> of your whole application is stored in an object tree within a single <a href="https://redux.js.org/glossary#store">store</a>.</p>
<h3 id="state-is-read-only">State is read-only</h3>
<p>The only way to change the state is to emit an <a href="https://redux.js.org/glossary#action">action</a>, an object describing what happened.</p>
<h3 id="changes-are-made-with-pure-functions">Changes are made with pure functions</h3>
<p>To specify how the state tree is transformed by actions, you write pure <a href="https://redux.js.org/glossary#reducer">reducers</a>.</p>
<h3 id="takeaway">Takeaway</h3>
<p>The important bit here is that everything is done with pure functions. As a result of this we prevent consumers from doing things like calling <code>dispatch</code> or <code>getState</code> from within a reducer.</p>
<p>As we talk about <code>createStore</code> we'll notice that the majority of the code enforces these constraints.</p>
<h1 id="function-signature">Function Signature</h1>
<p>Now that we've introduced this, let's dive into <code>createStore</code>. We'll start with the function signature.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/23ad2daace19787621102bf7c04e6d3a.js"></script>
<!--kg-card-end: html-->
<p>This takes three arguments <code>reducer</code> <code>preloadedState</code> and <code>enhancer</code>.</p>
<h2 id="reducer">Reducer</h2>
<p>The first one is hopefully straightforward. This is the <code>rootReducer</code> for your application. It's a pure function that takes a <code>state</code> and an <code>action</code> and returns a new <code>state</code>. It's most likely generated by <code><a href="https://github.com/reduxjs/redux/blob/master/src/combineReducers.js">combineReducers</a></code> which we'll cover in part 2.</p>
<h2 id="preloadedstate">preloadedState</h2>
<p>This is simply the state you'd like to start with. Most likely if you're using <code>preloadedState</code> you're doing one of two things. You have a server side rendered the page, or you have a data payload coming down with your source. Either way you &nbsp;have data you want loaded into redux as soon as the app is instantiated.</p>
<p>If you're not doing one of these you should probably just dispatch an action after the store is created.</p>
<h2 id="enhancer">enhancer</h2>
<p>I sometimes like to call this the <em>enchanter </em>because it really does some magic. The most common uses for this are the <a href="https://github.com/zalmoxisus/redux-devtools-extension">redux devtools</a> or adding <a href="https://github.com/reduxjs/redux/blob/master/src/applyMiddleware.js">middleware</a>, another thing we'll see in part 2.</p>
<h1 id="argument-validation-and-enhancing">Argument Validation and Enhancing</h1>
<p>The next lines of code are mostly argument validation. You can read the full source below but here's what it's doing:</p>
<ol>
<li>Ensures you've passed at most three arguments</li>
<li>Allow the user to only pass <code>reducer</code> and <code>enhancer</code>. If this happens it swaps the argument order.</li>
<li>Ensures the reducer is an actual function.</li>
</ol>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/8268324853199df738b0e3b82670b703.js"></script>
<!--kg-card-end: html-->
<p>There is one <em>very interesting </em>thing going on here though. You can see it on line 22 in the gist above.</p>
<p><code>enhancer(createStore)(reducer, preloadedState)</code></p>
<p>If an <code>enhancer</code> function is provided it calls it with <code>createStore</code> as an argument. This function then returns a new <code>createStore</code> function which only takes <code>reducer</code> and <code>preloadedState</code>.</p>
<p>This pattern is very common in the redux source, wrapping functions in other functions. In fact I like to say it's functions all the way down.</p>
<p>This is also how <a href="https://github.com/zalmoxisus/redux-devtools-extension">redux devtools</a> works. It wraps the createStore function so it can inject wrappers around every exported function and listen to their inputs and outputs. We won't dive too deeply into this, but you can check out <a href="https://github.com/zalmoxisus/redux-devtools-extension/blob/7b0be59e5b28162ca00e99dcd2f092b8df493a47/src/browser/extension/inject/pageScript.js">that source here</a>.</p>
<h1 id="internal-state">Internal State</h1>
<p>Before we get to the function declarations, <code>createStore</code> needs to set up some internal state.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/3a6d6b547dfb5b01b5f7b3f7aa1287a6.js"></script>
<!--kg-card-end: html-->
<p>Let's walk through each of these.</p>
<ul>
<li><code>currentReducer</code> - The root reducer redux calls.</li>
<li><code>currentState</code> - A reference to the key/value object that represents state</li>
<li><code>currentListeners</code> - This is a list of functions that have subscribed to redux.</li>
<li><code>nextListeners</code> - This is a reference to the updated listeners before a dispatch.</li>
<li><code>isDispatching</code> - Effectively a semaphore to block us from dispatching more than one action at a time.</li>
</ul>
<p>If these don't make total sense yet, especially the latter three, don't worry. We'll cover these more later.</p>
<h1 id="function-declarations">Function Declarations</h1>
<p>We're still inside of <code>createStore</code> but now we're declaring functions that will be used throughout the lifecycle of the store. Some of these will be returned as part of the store, others will only be used internally. I'll label each as we're going.</p>
<h2 id="ensurecanmutatenextlisteners">ensureCanMutateNextListeners</h2>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/acf68892b5ffce759b6c7ff1114c8287.js"></script>
<!--kg-card-end: html-->
<p>This function seems inconsequential but it's actually very important. Redux supports pub-sub or publish-subscribe. We have no invariants around when a consumer may decide to subscribe to our store or unsubscribe from it. As a result <code>nextListeners</code> needs to be mutable at all times. </p>
<p>Consider, a listener might even unsubscribe as a result of being called!</p>
<p>As a result of this we only call listeners in <code>currentListeners</code> and let any new subscriptions modify <code>nextListeners</code>. </p>
<p>Under the hood, this works because <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">Array.prototype.slice</a></code> returns a new reference to the list so <code>currentListeners</code> and <code>nextListeners</code> point to different arrays.</p>
<h2 id="getstate">getState</h2>
<p>This is a fan favorite, this is the function that returns <code>state</code>. It get's returned as part of the store and returns a reference to the current underlying <code>state</code> object.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/73d678df7c701ec3a3478d536d0e46c1.js"></script>
<!--kg-card-end: html-->
<p>You'll notice there's an invariant here that prevents us from calling this function during a dispatch. There's a good reason for this. When reducers are combined they only get a slice of the state, more on that in part 2. We don't want a reducer to get access to this function and derive it's state from another namespace state tree. As a result this throws if we're in the middle of a dispatch.</p>
<p>You may be thinking, but I call <code>getState</code> from a thunk! We're specifically referring to the plain action <code>dispatch</code>, not thunk <code>dispatch</code>. We'll cover thunks in part 2.</p>
<h2 id="subscribe">Subscribe</h2>
<p>The next function created is <code>subscribe</code>. This is what notifies listeners that something in the store has changed. This function is returned as part of the store.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/91a474355477ea619c32005de42d318a.js"></script>
<!--kg-card-end: html-->
<p>Hopefully this pattern is starting to look familiar. Subscribe takes a function that gets called every time the internal <code>state</code> updates. It also does the following validation:</p>
<ol>
<li>Make sure the argument is actually a function.</li>
<li>Make sure we're not attaching a subscribe in the middle of a dispatch.</li>
<li>Make sure we can mutate listeners, otherwise we couldn't subscribe!</li>
</ol>
<p>It also creates some internal state, <code>isSubscribed</code>. This is used in the <code>unsubscribe</code> function it returns.</p>
<h2 id="unsubscribe-">Unsubscribe.</h2>
<p>We've covered how we start listening to things, we call <code>subscribe</code>. But how do we stop? Well <code>subscribe</code> conveniently returns a function called <code>unsubscribe</code> that allows us to stop paying attention to redux.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/3600b8330c4a40417ea3bbc5c874beb1.js"></script>
<!--kg-card-end: html-->
<p>This function is very similar to <code>subscribe</code>. It checks <code>isSubscribed</code> (internal state) to see if it's already been called, and does some validation to make sure we're not currently <code>dispatching</code>. </p>
<p>Then it removes listener from the list.</p>
<h2 id="mapstatetoprops">mapStateToProps</h2>
<p>You might be thinking. I've been using redux for years, I've never called these functions. That's because most integration libraries will abstract all this away for us. In the case of the react-redux library this is taken care of in the <code><a href="https://github.com/reduxjs/react-redux/blob/85fb553ba8e3f4b0efc158d2e48aafb4c18a04d4/src/components/Provider.js">&lt;Provider /&gt;</a></code> component. We won't delve too far into that library but you can check out the <a href="https://github.com/reduxjs/react-redux">full source here</a>.</p>
<h1 id="dispatch">Dispatch</h1>
<p>It's worth a reminder that all of this is still being done in the context of the <code>createStore</code> function. The next function is the most important one, <code>dispatch</code>. This is the thing that updates the store and notifies listeners. Let's walk through it.</p>
<h2 id="validation">Validation</h2>
<p>Like every other function we've encountered. <code>dispatch</code> starts with a bunch of validation.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/1d2e71c16f656255bc7edc5d79c5f387.js"></script>
<!--kg-card-end: html-->
<p>You can see above it's enforcing the following rules</p>
<ol>
<li>We're only dispatching a plain object.</li>
<li>That object has a property called <code>type</code>.</li>
<li>We are not currently dispatching.</li>
</ol>
<p>But once again you might be thinking, but I dispatch functions! This is taken care of by the thunk middleware, something to look forward to in part 2 of this article.</p>
<h2 id="business-logic">Business Logic</h2>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/dd42acdb76fdeb65f66a5a45be266cac.js"></script>
<!--kg-card-end: html-->
<p>Now that we've made it this far, this function is probably much less impressive than you expected. Here's what it's doing.</p>
<ol>
<li>Set the <code>isDispatching</code> semaphore to <code>true</code></li>
<li>Call <code>currentReducer</code> with <code>currentState</code> and <code>action</code>. This returns a brand new state for our listeners.</li>
<li>Update listeners with the next set.</li>
<li>Loop through the list of listeners and call each of them.</li>
</ol>
<p>This is also where it's important that we keep <code>currentListeners</code> and <code>nextListeners</code> separate. While the reducer must be a synchronous pure function, there is no such invariant around any given listeners.</p>
<p>A listener may be async, take a long time, modify some global state, etc. It might even unsubscribe as a result of being called.</p>
<h1 id="two-more-functions">Two More Functions</h1>
<p>We've now covered the bulk of the business logic in <code>createStore</code>. There are now just two functions we need to mention, <code>replaceReducer</code> and <code>observable</code>.</p>
<h3 id="replacereducer">replaceReducer</h3>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/4ab3646462fcbac0eea9b6f4d4d75a75.js"></script>
<!--kg-card-end: html-->
<p>The function itself seems pretty straightforward, we take a new reducer and replace the one we use in the store. Then we dispatch an action announcing this has happened.</p>
<p>This action will also have the "side effect" of copying over any state that the new reducer needs to know about.</p>
<p>Why would you need this? This function is particularly useful for <a href="http://matthewgerstman.com/redux-code-split-typecheck/">code splitting. </a>I wrote an entire article about how to <a href="http://matthewgerstman.com/redux-code-split-typecheck/">code split a redux store</a> so I'll leave that as a followup.</p>
<h2 id="observable">Observable</h2>
<p>This last bit I've never actually used, so I don't think I'm qualified to go into too much detail about it. Effectively it adds support for to support <code>observables</code>, a proposal to ecmascript. It's &nbsp;just a simple wrapper around <code>subscribe</code>/<code>unsubscribe</code>.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/198ebd8fb599fe4563c0db2df6ad052a.js"></script>
<!--kg-card-end: html-->
<h1 id="wrapping-up">Wrapping Up</h1>
<p>The very last bit in <code>createStore</code> is initializing the state tree and exporting functions.</p>
<!--kg-card-begin: html-->
<script src="https://gist.github.com/matthew-gerstman/005294ffb5ff7563607cf1fa35a84638.js"></script>
<!--kg-card-end: html-->
<p>This is how users get access to <code>store.getState</code>, <code>store.dispatch</code>, <code>store.subscribe</code>, and <code>replaceReducer</code>. </p>
<h1 id="next-time-">Next Time!</h1>
<p>In our next article we'll be covering a lot of the tooling around redux. We'll talk about <code>applyMiddleware</code>, <code>bindActionCreators</code>, thunks, and more!</p>
<p>Part two is now available <a href="/writing/how-redux-works-2">here</a>!</p>
`.trim(),
  tags: ['Tech', 'redux'],
  banner_img: '/images/blog/how-redux-works/redux-architecture-hero.jpeg',
  heroImage: '',
  wordCount: 1667,
};

export default post;
